\documentclass[GBK,winfonts,a4paper,10pt]{ctexart}
\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage{graphics}
\usepackage{enumerate}
\usepackage{framed}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{hyperref}
\usepackage{mdwlist}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{listings}
\usepackage{xcolor}
\lstset{numbers=left, numberstyle=\small, keywordstyle=\color{blue!70}, commentstyle=\color{red!50!green!50!blue!50}, frame=shadowbox, rulesepcolor=\color{red!20!green!20!blue!20},escapeinside=``, xleftmargin=2em,xrightmargin=2em, aboveskip=1em}
\usepackage{geometry}

\newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}%
       
\lstdefinestyle{customc}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=single,
  xleftmargin=\parindent,
  language=C,
  showstringspaces=false,
  basicstyle=\fontsize{8pt}{8pt}\ttfamily,
  keywordstyle=\bfseries\color{green!40!black},
  commentstyle=\itshape\color{purple!40!black},
  identifierstyle=\color{blue},
  stringstyle=\color{orange},
  tabsize=4,
  numbers=none,
}

\lstset{escapechar=@,style=customc}

\pagestyle{fancy}
\hypersetup{pdfborder=0 0 0}

\usepackage{clrscode}

\usepackage{latexsym}

\begin{document}

\rhead{}
\lhead{}
\cfoot{\thepage}
\renewcommand{\footrulewidth}{0.4pt}
%\renewcommand{\thesection}{}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}
\setlength{\tabcolsep}{2pt}

\setlength{\parindent}{2em}

\thispagestyle{fancy}


\title{Operating System MIT 6.828 JOS Lab3 Report}
\author{Computer Science \\ ChenHao(1100012776) }
\date{\today}
\maketitle

\thispagestyle{fancy}

\tableofcontents

\newpage

\begin{section}{ Part A: User Environments and Exception Handling }
\par
lsof -i:xxxx    (xxxx是被占用的端口,得到占用端口的进程的PID)

\begin{subsection}{ Exercise 1 }
\par
分配物理内存和创建虚拟内存映射给envc，类似Lab2即可。
\begin{lstlisting}[language=C]
	envs = (struct Env *) boot_alloc(NENV * sizeof(struct Env));

// ... ...

    boot_map_region(kern_pgdir,
                    UENVS,
                    ROUNDUP(NENV * sizeof(struct Env), PGSIZE),
                    PADDR(envs),
                    PTE_U);
\end{lstlisting}
\end{subsection}

\begin{subsection}{ Exercise 2 }
\par
pmap只对内核进行了内存管理，而对于每个进程，都用有一个独立的内存空间，并且每个进程看起来都拥有整个内存空间，因此我们需要对进程也进行虚拟内存的管理，以及管理如何创建进程和进程的切换的问题。

\begin{subsubsection}{env\_init}
\par
env\_init类似page\_init，用来初始化NENV个进程管理结构，并且用单向链表来组织空闲的Env。其中要求env\_free\_list初始指向\&envs[0]。似乎这个的原因是在init.c中其会执行envs[0]。
\begin{lstlisting}[language=C]
void
env_init(void)
{
	// Set up envs array
	// LAB 3: Your code here.
    uint32_t i;
    env_free_list = envs;
    for (i = 0; i < NENV; i++) {
        envs[i].env_id = 0;
        envs[i].env_status = ENV_FREE;
        if (i + 1 != NENV)
            envs[i].env_link = envs + (i + 1);
        else 
            envs[i].env_link = NULL;
    }

	// Per-CPU part of the initialization
	env_init_percpu();
}
\end{lstlisting}
\end{subsubsection}

\begin{subsubsection}{env\_setup\_vm}
\par
env\_setup\_vm分配进程独立的Page Directory，即创建该进程的页目录。对于高于UTOP的虚拟地址PDE应与Kernel的页目录，对于低于UTOP的位置需要清0，这部分就是真正用户进程使用的页目录条目。
\par
为什么进程的页目录高于UTOP的虚拟地址的映射和Kernel的页目录一致？
\par
我觉得原因在于在内核管理进程的时候，在需用对进程使用的内存进行访问或者使用的时候就需要改用进程的Page Directory，但是同时还需要使用内核的代码或数据，因此保持一直可以保证这一点，不会造成错误和不必要的麻烦。而由于高于UTOP的虚拟地址的权限都是kernel权限的，因此在用户态的情况可以防止用户进行访问和修改，而且对于UTOP以上的内存对于用户进程是不允许访问的，这部分对于用户进程来说是不会使用的。
\begin{lstlisting}[language=C]
static int
env_setup_vm(struct Env *e)
{
	int i;
	struct PageInfo *p = NULL;

	// Allocate a page for the page directory
	if (!(p = page_alloc(ALLOC_ZERO)))
		return -E_NO_MEM;

    p->pp_ref++;
    e->env_pgdir = (pde_t *)page2kva(p);
    memcpy(e->env_pgdir, kern_pgdir, PGSIZE);
    memset(e->env_pgdir, 0, PDX(UTOP) * sizeof(pde_t));

	// UVPT maps the env's own page table read-only.
	// Permissions: kernel R, user R
	e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;

	return 0;
}
\end{lstlisting}
\end{subsubsection}

\begin{subsubsection}{region\_alloc}
\par
region\_alloc用于为进程分配物理内存，因此应该使用对应进程的页目录和页表。
\begin{lstlisting}[language=C]
static void
region_alloc(struct Env *e, void *va, size_t len)
{
    uint32_t addr = (uint32_t)ROUNDDOWN(va, PGSIZE);
    uint32_t end  = (uint32_t)ROUNDUP(va + len, PGSIZE);
    struct PageInfo *pg;
    // cprintf("region_alloc: %u %u\n", addr, end);
    for ( ; addr != end; addr += PGSIZE) {
        pg = page_alloc(1);
        if (pg == NULL) {
            panic("region_alloc : can't alloc page\n");
        } else {
            if (page_insert(e->env_pgdir, pg, (void *)addr, PTE_U | PTE_W) != 0) {
                panic("region_alloc : page_insert fail\n");
            }
        }
    }
    return;
}
\end{lstlisting}
\end{subsubsection}


\begin{subsubsection}{load\_icode}
\par
load\_icode将目标文件放入内存中，存放的虚拟内存的位置由目标文件指定。这个函数有两个需要注意的地方，第一个是首先使用region\_alloc分配对应虚拟地址的内存，而这个映射仅在该进程的页表中存在，在内核中是不存在的，因此在memcpy和memset的时候需要使用的该进程的页目录，而不应该使用内核的页目录。这个地方非常阴险，我一开始就掉进了这个陷阱中。
\par
第二个需要注意的地方就是需要将elf->e\_entry即目标文件的入口放入进程环境的eip中。
\begin{lstlisting}[language=C]
static void
load_icode(struct Env *e, uint8_t *binary, size_t size)
{
    struct Elf * elf = (struct Elf *)binary;
    if (elf->e_magic != ELF_MAGIC) {
        panic("error elf magic number\n");
    }
    struct Proghdr *ph, *eph;
    ph = (struct Proghdr *) ((uint8_t *) elf + elf->e_phoff);
    eph = ph + elf->e_phnum;

    lcr3(PADDR(e->env_pgdir));
    for (; ph < eph; ph++) {
        if (ph->p_type == ELF_PROG_LOAD) {
            region_alloc(e, (void *)ph->p_va, ph->p_memsz);
            memcpy((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);
            memset((void *)(ph->p_va) + ph->p_filesz, 0, ph->p_memsz - ph->p_filesz);
        }
    }
    e->env_tf.tf_eip = elf->e_entry;

    lcr3(PADDR(kern_pgdir));
    region_alloc(e, (void *)(USTACKTOP - PGSIZE), PGSIZE);

    return;
}
\end{lstlisting}
\end{subsubsection}


\begin{subsubsection}{env\_create}
\par
这个函数需要做就是将代码导入内存中，需要分两布：第一创建进程的地址空间的页目录以及设置环境变量，第二是将目标文件的代码导入内存中。
\begin{lstlisting}[language=C]
void
env_create(uint8_t *binary, size_t size, enum EnvType type)
{
    struct Env * e;
    int r = env_alloc(&e, 0);
    if (r < 0) {
        panic("env_create: %e\n", r);
    }
    load_icode(e, binary, size);
    e->env_type = type;
    return;
}
\end{lstlisting}
\end{subsubsection}

\begin{subsubsection}{env\_run}
\par
只需要进行切换一下即可。遗留问题如果curenv的状态为别的状态怎么办？之后回来再来看好了。
\begin{lstlisting}[language=C]
void
env_run(struct Env *e)
{
    if (curenv != NULL) {
        // context switch
        if (curenv->env_status == ENV_RUNNING) {
            curenv->env_status = ENV_RUNNABLE;
        }
        // how about other env_status ? e.g. like ENV_DYING ?
    }
    curenv = e;
    curenv->env_status = ENV_RUNNING;
    curenv->env_runs++;
    
    lcr3(PADDR(curenv->env_pgdir));

    env_pop_tf(&curenv->env_tf);    
	panic("env_run not yet implemented");
}
\end{lstlisting}
\end{subsubsection}

\par
gdb得到结果顺利到达int \$0x30处。
\end{subsection}

\begin{subsection}{ Exercise 3 }
\end{subsection}

\begin{subsection}{ Exercise 4 }
\par
由IA-32手册知是否需要Error Code的情况：
\begin{center}
    \begin{tabular}{ | l | l | l |}
    \hline
Interrupt   &   ID   &   Error Code  \\ \hline
divide error	&	0	&	N	\\ \hline 				
debug exception &  1  & N	\\ \hline 
non-maskable interrupt	&	2	&	N	\\ \hline 
breakpoint	&	3	&	N	\\ \hline 
overflow		&	4	&	N	\\ \hline 
bounds check		&	5	&	N	\\ \hline 
illegal opcode	&	6	&	N	\\ \hline 
device not available		&	7	&	N	\\ \hline 
double fault				&	8	&	N	\\ \hline 
invalid task switch segment	&	10	&	Y	\\ \hline 
segment not present	&	11	&	Y	\\ \hline 
stack exception	&	12	&	Y	\\ \hline 
general protection fault	&	13	&	Y	\\ \hline 
page fault	&	14	&	Y	\\ \hline 
floating point error	&	16	&	N	\\ \hline 
aligment check	&	17	&	Y		\\ \hline 
machine check		&	18	&	N	\\ \hline 
SIMD floating point error		&	19	&	N	\\ \hline
    \end{tabular}
\end{center}

\begin{subsubsection}{ trapentry.S }
\par
trapentry.S就是设置各种终端的入口，以及进入中断后队进程状态的保护。于是在trapentry.S的.text段中设置对应入口的汇编即可，对于状态的保护即在栈中建Trapframe,根据inc/trap.h中的Trapframe结构，存放相应的寄存器，并将GD\_KD导入\%ds和\%es中，保存\%esp执行trap()函数。
\begin{lstlisting}[language=C]
.text
 /*
 * Lab 3: Your code here for generating entry points for the different traps.
 */
 	TRAPHANDLER_NOEC(vec0, T_DIVIDE)
 	TRAPHANDLER_NOEC(vec1, T_DEBUG)
 	TRAPHANDLER_NOEC(vec2, T_NMI)
 	TRAPHANDLER_NOEC(vec3, T_BRKPT)
 	TRAPHANDLER_NOEC(vec4, T_OFLOW)

 	TRAPHANDLER_NOEC(vec6, T_BOUND)
	TRAPHANDLER_NOEC(vec7, T_DEVICE)
 	TRAPHANDLER_NOEC(vec8, T_DBLFLT)

 	TRAPHANDLER(vec10, T_TSS)
 	TRAPHANDLER(vec11, T_SEGNP)
 	TRAPHANDLER(vec12, T_STACK)
 	TRAPHANDLER(vec13, T_GPFLT)
 	TRAPHANDLER(vec14, T_PGFLT) 

 	TRAPHANDLER_NOEC(vec16, T_FPERR)
 	TRAPHANDLER(vec17, T_ALIGN)
 	TRAPHANDLER_NOEC(vec18, T_MCHK)
 	TRAPHANDLER_NOEC(vec19, T_SIMDERR)

/*
 * Lab 3: Your code here for _alltraps
 */
_alltraps:
	pushl %ds
	pushl %es
	pushal

	movl $GD_KD, %eax
	movw %ax, %ds
	movw %ax, %es

	pushl %esp
	call trap
\end{lstlisting}
\end{subsubsection}

\begin{subsubsection}{ trap\_init }
\par
trap\_init为初始化IDT表，并将表头导入IDTR中。IDT表中的项如下图所示：
\includegraphics[scale=0.5]{IDTGateDescriptors.png}
因此将对应项传入SETGATE即可。
\begin{lstlisting}[language=C]
// In inc/mmu.h
// Set up a normal interrupt/trap gate descriptor.
// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
    //   see section 9.6.1.3 of the i386 reference: "The difference between
    //   an interrupt gate and a trap gate is in the effect on IF (the
    //   interrupt-enable flag). An interrupt that vectors through an
    //   interrupt gate resets IF, thereby preventing other interrupts from
    //   interfering with the current interrupt handler. A subsequent IRET
    //   instruction restores IF to the value in the EFLAGS image on the
    //   stack. An interrupt through a trap gate does not change IF."
// - sel: Code segment selector for interrupt/trap handler
// - off: Offset in code segment for interrupt/trap handler
// - dpl: Descriptor Privilege Level -
//	  the privilege level required for software to invoke
//	  this interrupt/trap gate explicitly using an int instruction.
#define SETGATE(gate, istrap, sel, off, dpl) ...
// ----------------------------------------------------------------------------

void
trap_init(void)
{
	extern struct Segdesc gdt[];

	// LAB 3: Your code here.
	void vec0();
	void vec1();
	void vec2();
	void vec3();
	void vec4();
	void vec6();
	void vec7();
	void vec8();
	void vec10();
	void vec11();
	void vec12();
	void vec13();
	void vec14();
	void vec16();	
	void vec17();
	void vec18();
	void vec19();

	SETGATE(idt[0], 0, GD_KT, vec0, 0);
	SETGATE(idt[1], 0, GD_KT, vec1, 0);
	SETGATE(idt[2], 0, GD_KT, vec2, 0);
	SETGATE(idt[3], 0, GD_KT, vec3, 0);
	SETGATE(idt[4], 0, GD_KT, vec4, 0);

	SETGATE(idt[6], 0, GD_KT, vec6, 0);
	SETGATE(idt[7], 0, GD_KT, vec7, 0);
	SETGATE(idt[8], 0, GD_KT, vec8, 0);
	SETGATE(idt[10], 0, GD_KT, vec10, 0);
	SETGATE(idt[11], 0, GD_KT, vec11, 0);
	SETGATE(idt[12], 0, GD_KT, vec12, 0);
	SETGATE(idt[13], 0, GD_KT, vec13, 0);
	SETGATE(idt[14], 0, GD_KT, vec14, 0);

	SETGATE(idt[16], 0, GD_KT, vec16, 0);
	SETGATE(idt[17], 0, GD_KT, vec17, 0);
	SETGATE(idt[18], 0, GD_KT, vec18, 0);
	SETGATE(idt[19], 0, GD_KT, vec19, 0);

	// Per-CPU setup 
	trap_init_percpu();
}
\end{lstlisting}
执行，成功了！
\end{subsubsection}

\end{subsection}

\begin{subsection}{ Chanllenge }
\par
好吧，看来Exercise4写挫了。。。得重写了
\end{subsection}

\begin{subsection}{ Question }
\par
1. 有的中断需要error code，有的中断不需要。同时无法保存对应的中断号。因此需要分开处理。
\par
2. 因为IDT中设置page fault只能允许内核产生这种终端，如果在用户态产生page fault则会触发general protection fault。
\par
如果用户可以随意产生page fault，则可能有恶意的进程疯狂产生page fault将整个内存空间占满。因此page fault只能在内核中处理。
\end{subsection}
\end{section}

\begin{section}{ Part B }
\begin{subsection}{ Exercise 5 }
\par
根据trapno来分配即可
\begin{lstlisting}[language=C]
    switch (tf->tf_trapno) {
        case T_PGFLT:
            page_fault_handler(tf);
            break;
        default:
            break;
    }
\end{lstlisting}
\end{subsection}

\begin{subsection}{ Exercise 6 }
\par
同理
\begin{lstlisting}[language=C]
    switch (tf->tf_trapno) {
        case T_PGFLT:
            page_fault_handler(tf);
            break;
        case T_BRKPT:
            monitor(tf); 
            break;
        default:
            break;
    }
\end{lstlisting}
\end{subsection}

\begin{subsection}{ Challenge }
\end{subsection}

\begin{subsection}{ Question }
\par
3. 由于breakpoint的陷阱是可以面向用户态的进程的，因此需要将IDT的特权位置1，允许用户态进程使用。如果不设置则用户无法使用断点中断。
\par
4. 
\end{subsection}


\end{section}

\end{document}



















